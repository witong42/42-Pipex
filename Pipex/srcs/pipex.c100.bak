/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipex.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: witong <witong@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/28 10:22:07 by witong            #+#    #+#             */
/*   Updated: 2024/10/28 13:30:55 by witong           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
typedef struct s_pipex_params
{
	char	*infile;
	char	*outfile;
	char	**cmds;
	int		nb_cmds;
	bool	mode;
	char	**env;
	int		input_fd;
	int		output_fd;
} t_pipex_params;
*/

#include "pipex.h"

t_pipex_params	init_params(int ac, char **av, char **env)
{
	t_pipex_params params;
	params.infile = av[1];
	params.outfile = av[4];
	params.cmds = &av[2];
	params.nb_cmds = 2;
	params.env = env;
	return (params);
}
void	open_files(t_pipex_params *params)
{
	params->input_fd = open(params->infile, O_RDONLY);
	if (params->input_fd < 0)
		print_error("Error opening infile");
	params->output_fd = open(params->outfile, O_WRONLY | O_CREAT | O_TRUNC, 0777);
	if (params->input_fd < 0)
	{
		close(params->output_fd);
		print_error("Error opening outfile");
	}
}
void	find_path(t_pipex_params *params)
{
	int		i;
	char	*path;

	i = 0;
	while (params->env[i])
	{
		if (params->env[i][0] == 'P')
		{
			path = ft_strnstr(params->env[i], "PATH=", 5);
			if (path)
			{
				params->path = ft_split(path + 5, ':');
				break ;
			}
		}
		i++;
	}
}
void	execute(t_pipex_params *params,int k)
{
	char	**cmd;
	char	*path;
	char	*path_full;
	int		res;

	cmd = ft_split(params->cmds[k], ' ');
	if(!cmd || !cmd[0])
		print_error("Error malloc split");
	for(int i = 0; params->path[i];i++)
	{
	path = ft_strjoin(params->path[i], "/");
	path_full = ft_strjoin(path, cmd[0]);
	free(path);
	res = access(path_full, X_OK);
	if (res == 0)
		break;
	free(path_full);
	}
	// ft_printf("%s\n", path_full);
	// printf("%d\n", res);
	char *full[2];
	full[0] = params->cmds[0];
	full[1] = NULL;
	// printf("%s\n",full[0]);
	execve(path_full,cmd,params->env);
}

int	main(int ac, char **av, char **env)
{
	t_pipex_params	params;
	int	fd[2];
	pid_t pipefd;

	if (ac == 5)
	{
		params = init_params(ac, av, env);
		open_files(&params);
		find_path(&params);
		pipe(fd);
		pipefd = fork();
		if (pipefd == 0)
		{
			// printf("je suis la \n");
			//exemple /usr/local/bin + / + cmd
			dup2(fd[1],1);
			dup2(params.input_fd,0);
			close(fd[0]);
			close(fd[1]);
			execute(&params,0);
			exit(0);
		}
		// printf("je suis le \n");
		waitpid(pipefd,NULL,0);
		pipefd = fork();
		if (pipefd == 0)
		{
			// printf("je suis la \n");
			// //exemple /usr/local/bin + / + cmd
			// printf("%d\n",params.output_fd);
			dup2(params.output_fd,1);
			dup2(fd[0],0);
			close(fd[0]);
			close(fd[1]);
			execute(&params,1);
			exit(0);
		}
		// printf("je suis le \n");
		close(fd[0]);
		close(fd[1]);
		waitpid(0,NULL,0);
		// fd[0] == sortie;
		// fd[1] == entree;
	}
}
